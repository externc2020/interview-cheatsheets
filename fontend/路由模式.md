# 路由背景
现在web应用基本都是react,vue实现出来的单页面(spa)网页应用，只有一个index.html

所以现在web应用需要配合spa实现以下几个功能
- url改变但是浏览器不发送请求给服务器
- 监听url的变化
- 再不刷新页面的情况下动态改变url的数值

# [History模式](https://developer.mozilla.org/zh-CN/docs/Web/API/History)

History 接口允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录

如果你在一个浏览器标签页中 跳转到其他页面 history.length会持续+1，并且可以通过
- history.back() 回退上一级页面
- history.forward() 返回之后页面
- history.go(number) 跳转number次数的页面 -1为上一页，1为下一页
- back,forward,go都会返回undefined再没有页面可以跳转的时候，并且不会发生页面跳转

利用了HTML5 History接口 中新增的pushState() 和replaceState() 方法。需要特定浏览器支持

````javascript
const state = { 'page_id': 1, 'user_id': 5 }
const title = ''
const url = 'hello-world.html'

history.pushState(state, title, url)
````

# hash模式

在url最后面加上# 例如
```bash
http://127.0.0.1:5500/前端路由/hash.html#/page1
```

url后面的#/page1就是hash值

- hash的变化不会导致浏览器向服务器发送请求
- windows.location.hash可以获取到hash的数值
- hashchange是hash改变的callback

```javascript
class RouterClass {
      constructor() {
        this.routes = {}; // 记录路径标识符对应的cb
        this.currentUrl = ""; // 记录hash只为方便执行cb
        window.addEventListener("load", () => this.render());
        window.addEventListener("hashchange", () => this.render());
      }

      /* 初始化 */
      static init() {
        window.Router = new RouterClass();
      }

      /* 注册路由和回调 */
      route(path, cb) {
        this.routes[path] = cb || function() {};
      }

      /* 记录当前hash，执行cb */
      render() {
        this.currentUrl = window.location.hash.slice(1) || "/";
        this.routes[this.currentUrl]();
      }
    }


    RouterClass.init();
    const ContentDom = document.querySelector(".content-div");
    const changeContent = content => (ContentDom.innerHTML = content);

    Router.route("/", () => changeContent("默认页面"));
    Router.route("/page1", () => changeContent("page1页面"));
    Router.route("/page2", () => changeContent("page2页面"));
  </script>
```
