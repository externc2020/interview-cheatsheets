# 系统架构

### 名词

- 高内聚，低耦合
- 分层架构，MVC，SOA，微服务，DDD，整洁架构（洋葱架构），六边形架构（端口适配器架构），CQRS 读写分离
- 服务治理：Kubernetes，Spring Cloud，Dubbo

### 常见问题

1. 微服务的服务划分依据是什么？DDD
2. 分层架构、MVC、SOA 和微服务有什么区别？

### 互联网三高

- 高并发（吞吐）
- 高可用
- 高性能

## 面向对象编程（OOP）

封装、继承、多态

### SOLID 原则

- 单一职责（Single-responsibility principle）
- 开闭原则（Open-closed principle）
- 里氏替换（Liskov substitution principle）
- 接口隔离（Interface segregation principle）
- 依赖反转（Dependency inversion principle）

遵守以上五个原则可以提升软件的**可维护性**和**可扩展性**

### 迪米特法则（Law of Demeter，LoD）

- 又叫作最少知识原则（Least Knowledge Principle，LKP)
- 只与你的直接朋友交谈，不跟“陌生人”说话

### 合成复用原则（Composite Reuse Principle）

- 组合优于继承

### UML 类图

- 泛化（Generalization）继承关系
- 实现（Realization）类和接口的关系
- 关联（Association）1:n n:n
- 聚合（Aggregation）整体和部分的关系，且部分可以离开整体而单独存在
- 组合（Composition）整体与部分的关系，但部分不能离开整体而单独存在
- 依赖（Dependency）是一种使用的关系，即一个类的实现需要另一个类的协助

### 设计模式（经典 23 种，GoF）

- 创建型（Creational）
  * Abstract factory
  * Builder
  * Factory method
  * Prototype
  * Singleton
- 结构型（Structural）
  * Adapter
  * Bridge
  * Composite
  * Decorator
  * Facade
  * Flyweight
  * Proxy
  * Delegation(委派模式): 非 GoF
- 行为型（Behavioural）
  * Chain of responsibility
  * Command
  * Interpreter
  * Interator
  * Mediator
  * Memento
  * Observer or Publish/subscribe
  * State
  * Strategy
  * Template method
  * Visitor

### JavaSE 用到了哪些设计模式

- 装饰器

### Spring 用到了哪些设计模式

- 工厂模式：BeanFactory
- 单例模式：Bean
- 模板方法：JdbcTemplate, RestTemplate
- 代理模式：AOP
- 委派模式：DispatcherServlet


### 微服务（Microservices）

- DDD
- 和 SOA 的区别


### 服务网格（Service Mesh)

- istio
- sidecar


### 云原生（Cloud Native）The 12-factor App

1. Codebase
2. Dependencies
3. Config
4. Backing services
5. Build, release, run
6. Processes
7. Port binding
8. Concurrency
9. Disposability
10. Dev/prod parity
11. Logs
12. Admin processes


# 高可用


### 宏观思路

- 冗余：备份，集群，负载均衡，弹性
- 分治：读写分离，分库分表（分片、sharding）
- 容错：隔离，超时，重试，熔断，限流，降级
- 监控：应用监控（日志，JVM），链路监控，实例监控（物理机），安全监控，早发现早预防

### SLA 指标

SLA（Service-Level Agreement）是一种服务承诺

- 可用性（几个9）：99.9% 指的是一天当中系统服务将会有大约86秒的服务间断期
- 延迟：TP99 = P99 = 99线，表示在100个请求里面有99个请求的响应时间会少于1秒，而剩下的1个请求响应时间会大于1秒
- 准确性：导致系统产生内部错误的有效请求数 / 期间的有效请求总数
- 系统容量：QPS(Query) = RPS(Request)

## 集群（Cluster）

- 降低成本
- 提高性能，可靠性，可扩展性（灵活性）
- 核心技术：任务调度（负载均衡）


### 负载均衡

- 算法：轮询（Round Robin）+ 加权，随机（Random）+ 加权，源地址哈希，最小连接数
- HAProxy

## 容错

- 熔断, 降级：Hystrix
- 隔离：线程，线程池
- 超时，重试：Feign
- 限流：Sentinel

## 监控

意义：提供一种反馈

### 解决方案
- Nagios
- Zabbix

### 链路监控 + APM

#### CAT
- 定位：实时应用监控平台
- 研发团队：美团
- 埋点方式：代码埋点（拦截器，注解，过滤器等）
- 颗粒度：代码
- 不符合 CNCF OpenTracing 标准
- 采集数据：
  * 系统层：cpu,mem,disk,load
  * 应用层：JVM,链路,web调用,方法代码执行次数耗时
  * 业务层：KPI数据，手动埋点
- 消息传输：Netty
- 存储：MySQL，HDFS，本地文件

#### Zipkin
- 定位：分布式追踪系统
- 研发团队：Twitter
- 埋点方式：HTTP 拦截器
- 颗粒度：接口
- 符合 CNCF OpenTracing 标准
- 采集数据：
  * 应用层：链路,接口执行次数耗时
- 消息传输：HTTP 消息队列
- 存储：MySQL，ES，Cassandra

#### SkyWalking

- 定位：分布式追踪系统, 应用性能监控系统（APM）
- 研发团队：吴晟, Apache
- 埋点方式：Java 探针，字节码增强
- 颗粒度：方法
- 符合 CNCF OpenTracing 标准
- 采集数据：
  * 系统层：cpu，mem，disk
  * 应用层：JVM，链路，方法执行次数耗时
- 消息传输：gRPC
- 存储：MySQL，ES，H2，TiDB，ShardingSphere

#### Pinpoint

- 定位：分布式追踪系统, 应用性能监控系统（APM）
- 研发团队：韩国 Naver 团队
- 埋点方式：Java 探针，字节码增强
- 颗粒度：方法
- 符合 CNCF OpenTracing 标准
- 采集数据：
  * 系统层：cpu，mem，disk
  * 应用层：JVM，链路，方法执行次数耗时
- 消息传输：Thrift
- 存储：HBase


### 监控系统

- 采集
- 存储
- 展示
- 报警

## HA 实例

### MySQL

### Eureka

### Redis
- 模式：主从复制，哨兵模式，集群模式

### RabbitMQ

### RocketMQ

### Kafka

### InfluxDB

### Prometheus

### ElasticSearch


## 常见问题

- [雪崩](https://en.wikipedia.org/wiki/Cascading_failure)


# 高并发

### 常见名词

- 锁，乐观，悲观，偏向，轻量，重量，自旋，无锁
- CAS = Compare And Swap
- JUC = java.util.concurrent
- 可见性，有序性，原子性

### 常见问题

- synchronized与lock的区别，使用场景
- Java锁有哪些种类，以及区别
- 如何保证内存可见性
- volatile关键字的如何保证内存可见性

### 线程安全有三要素

- 可见性
- 有序性
- 原子性

### as-if-serial 原则（JVM 规范）

就是单线程指令重排后最后效果和顺序写效果一致

### happens-before 原则（JVM 规范）

- 程序顺序规则：在一个线程内部，按照程序代码的书写顺序，书写在前面的代码操作Happens-Before书写在后面的代码操作。
- 锁定规则：对锁M解锁之前的所有操作Happens-Before对锁M加锁之后的所有操作。
- volatile变量规则：对一个volatile变量的写操作及这个写操作之前的所有操作Happens-Before对这个变量的读操作及这个读操作之后的所有操作。
- 线程启动规则：Thread对象的start方法及书写在start方法前面的代码操作Happens-Before此线程的每一个动作。
- 线程终止规则：线程中的任何操作都Happens-Before其它线程检测到该线程已经结束。
- 中断规则：一个线程在另一个线程上调用interrupt,Happens-Before被中断线程检测到interrupt被调用。
- 终结器规则：一个对象的构造函数执行结束Happens-Before它的finalize()方法的开始。
- 传递性规则：如果操作A Happens-Before B，B Happens-Before C，那么可以得出操作A Happens-Before C。

### 反应堆模型

NIO 1.4 selectors /reactor pattern
NIO.2 1.7 completion handlers / proactor pattern / aio
从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.
IO复用下的事件驱动模型
reactor：能收了你跟俺说一声。
proactor: 你给我收十个字节，收好了跟俺说一声。IOCP/Boost.Asio
callback就是reactor
future/await就是proactor

# 高性能

##  理论

- 并行计算 Amdahl 定律：为了提高性能，不能只增加 CPU 数量（后期收效甚微），还要增加系统的并行度（高并发）

## CPU（缓存）+ 内存

- 缓存行（Cache Line）伪共享
- 大页
- 并行计算 OpenMP
- SMP（Symmetric Multi-Processor）对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。SMP的优点是能够保证内存一致性，缺点是这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。常用的PC机就属于这种。
- NUMA（Non-Uniform Memory Access）非统一内存访问架构，非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度，这也是非一致存储访问NUMA的由来。NUMA优点是可以较好地解决原来SMP系统的扩展问题，缺点是由于访问远地内存的延时远远超过本地内存，因此当CPU数量增加时，系统性能无法线性增加。
- SIMD（Single Instruction，Multiple Data）SSE，AVX

SSE 优化 HashMap

## 磁盘 IO

- Page Cache
- SSD
- 顺序写

## 网络 IO

### 非阻塞 IO

## Unikernel

- 自定义内核，打包应用程序进入内核，突破内核态用户态，榨干硬件性能，anykernel 概念
- 一种实现 NetBSD rump kernel

## JVM
- vert.x
- GraalVM
- QUARKUS
