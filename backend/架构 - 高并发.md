并发 -> 锁

synchronized与lock的区别，使用场景。看过synchronized的源码没
volatile关键字的如何保证内存可见性
happen-before原则
你说你熟悉并发编程，那么你说说Java锁有哪些种类，以及区别（果然深度不一样）
如何保证内存可见性


JUC = java.util.concurrent

自旋，乐观，悲观，偏向

CAS 原子性问题，AtomicInteger JUC 大多是时 CAS，CPU 指令也不能保障原子性（LOCK_IF_MP，这种汇编实现是因为多核情况下不行，解决方法汇编加 lock = lock cmpxchg，lock 锁定总线（优先锁定缓存行，然后锁定北桥）

什么时候 CAS 乐观锁，什么时候悲观锁 synchronized
1.优先悲观锁（CAS 是 spin lock 消耗 CPU）
2.CAS 乐观锁适合锁占用时间短的操作
3.synchronized 1.5 后有锁升级的过程（最新实现）偏向 -> 自旋（轻量，无锁） -> 重量（悲观）
4. 偏向(biased locking)（mark word 放当前线程指针），轻量 用户态；重量 内核态，向系统升级
5. 偏向有竞争，其他线程通过 CAS 强，然后升级轻量锁（CAS，自旋，无锁），重度竞争（耗时过长 wait）升级重量锁（后面有竞争队列和等待队列）

字节码 monitorenter monitorexit 1 个 enter 对应 两个 exit，一个是正常退出，一个是异常退出

偏向锁 默认延迟 4 秒
偏向锁要撤销，所以在明知某些资源会有多线程竞争，就不用偏向锁，所以会有延迟
-XX:BiasedLockingStartupDelay=0

对象锁状态（markword） 8 字节分布及状态

synchronized lock cmpxchg
volatile 内存屏障 就是 lock addl 汇编指令下往某个寄存器上加一个 0
指令重排，内存屏障，缓存行对齐
volatile = 线程可见，禁止指令重排


线程安全有三要素：可见性、有序性、原子性
 volatile不保证操作的原子性


as-if-serial
happens-before
程序顺序规则：在一个线程内部，按照程序代码的书写顺序，书写在前面的代码操作Happens-Before书写在后面的代码操作。
锁定规则：对锁M解锁之前的所有操作Happens-Before对锁M加锁之后的所有操作。
volatile变量规则：对一个volatile变量的写操作及这个写操作之前的所有操作Happens-Before对这个变量的读操作及这个读操作之后的所有操作。
线程启动规则：Thread对象的start方法及书写在start方法前面的代码操作Happens-Before此线程的每一个动作。
线程终止规则：线程中的任何操作都Happens-Before其它线程检测到该线程已经结束。
中断规则：一个线程在另一个线程上调用interrupt,Happens-Before被中断线程检测到interrupt被调用。
终结器规则：一个对象的构造函数执行结束Happens-Before它的finalize()方法的开始。
传递性规则：如果操作A Happens-Before B，B Happens-Before C，那么可以得出操作A Happens-Before C。

ThreadLocal
ForkJoin Pool

在同一个缓存行存在竞争

volatile 有内存屏障，会导致缓存行失效

通过缓存行 padding 实现伪共享，确保不在同一个内存行

一般内存行是 64 个字节

disruptor ringbuffer

lmax

long p1, p2, p3, p4, p5, p6, p7
前后填充，解决缓存行伪共享

1.8 加入
@sun.misc.Contended 优雅解决缓存行伪共享


这是 JVM 规范
happends-before
as-if-serial 就是单线程指令重排后最后效果和顺序写效果一致

volatile 可见性就是防止线程拷贝


AQS？CAS + volatile
java.util.concurrent包的核心类是AbstractQueuedSynchronizer，AQS是一个同步器+阻塞锁的基本架构，用于控制加锁和释放锁，并在内部维护一个FIFO的线程等待队列。

DCL（double-check lock） 单利为什么要加 volatile
public class Singleton {
    private volatile static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
Java可以利用JVM内部静态类装载的特点实现“延迟初始化占位类模式”来达到同样的效果

用 hsdis（hotspot disassembler）观察 synchronized volatile

JIT

高并发（吞吐）

CAS, ABA（引用，泄漏造成大问题，版本号/bool）

ThreadLocal 内部并非 HashMap 而是 ThreadLocalMap
Entry 是 WeakReference
同时 entry value 也没有链表结构
内存泄漏，WeakReference 导致 value 没有回收，记得 finaly localName.remove();
那为什么ThreadLocalMap的key要设计成弱引用？
key不设置成弱引用的话就会造成和entry中value一样内存泄漏的场景。
ThreadLocal的不足，我觉得可以通过看看netty的fastThreadLocal来弥补

NIO 1.4 selectors /reactor pattern
NIO.2 1.7 completion handlers / proactor pattern / aio
从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.
IO复用下的事件驱动模型
reactor：能收了你跟俺说一声。
proactor: 你给我收十个字节，收好了跟俺说一声。IOCP/Boost.Asio
callback就是reactor
future/await就是proactor
