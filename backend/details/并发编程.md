# 并发编程

### 并发与并行区别

- 并发（Concurrency）指处理多个任务的能力，并发任务之间不一定要同在一时刻发生（时间片轮转，看似同时发生）
- 并行（Parallelism）指同一时刻执行多个任务，具有并发的含义
- 并发不一定并行，参见[《Concurrency is not parallelism》](https://blog.golang.org/waza-talk)

### 竞态条件（Race Condition）

- 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件
- 例：两个线程同时给一个变量加一，最后可能只加了一

### 临界区（Critical Section）

- 导致竞态条件发生的代码区称作临界区

### 并发关系

- 互斥（Mutual Exclusion = mutex）
- 同步（Synchronization）

### 线程安全三大问题

- 原子性
- 可见性
- 有序性

### 解决方案

- 信号量 Semaphore/管程 Monitor（二者等价）
- 锁（lock = mutex）
- 读写锁（Readers-writer locks）
- 可重入锁（Recursive locks = Reentrant locks）
- 消息传递（Message passing）Actor 模式的核心 channel

并发工具 | Linux | Pthread | Java
--------|-------|---------|-------
Semaphore | Yes | No | Yes
Monitor | No | No | Yes
Mutex | Yes | Yes | Yes
Spinlock | Yes | Yes | Yes
Condition | No | Yes | Yes
RW locks | Yes | Yes | Yes
RCU | Yes | No | No
Barrier | Yes | Yes | Yes

<details>
<summary>Linux mutex</summary>

```c
struct mutex {
  atomic_t count;
  spinlock_t wait_lock;
  struct list_head wait_list;
}

#include <linux/mutex.h>
DEFINE_MUTEX(name);
mutex_init(struct mutex *lock);
void mutex_lock(struct mutex *lock);
int mutex_lock_interruptible(struct mutex *lock);
int mutex_trylock(struct mutex *lock);
void mutex_unlock(struct mutex *lock);
int mutex_is_locked(struct mutex *lock);
```
</details>

<details>
<summary>Pthread mutex</summary>

```c
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
</details>

### 副作用

- 死锁（Dead Lock）
- 饥饿（Starvation）
- 优先级倒置（Priority Inversion）：重新组织代码；优先级置顶协议；优先级继承协议
- 忙等（Busy Waiting）、活锁（Live Lock）
- 锁封护（Lock Convoy）：同等优先级线程 A，B；A 频繁争抢导致上下文切换耗时，B 不参与争抢；最后使得两个同等优先级线程获得的 CPU 时间不等，调度公平性受损


### 信号量（Semaphore）

- 由 Dijkstra 在 1965 年提出
- 由一个整型变量（s，代表共享资源数目）和两个原子操作（PV=wait/signal）组成
- 荷兰语 P=Prolaag 减少；V=Verhoog 增加
- s=0/1 -> 互斥锁
- 缺点：PV 成对使用，顺序很重要 -> 容易出错 -> 死锁

### 管程（Monitor）

- 共享变量和对共享变量的操作是被封装起来的，更契合 OOP
- 管程实现方式的演化
  * Brinch-Hanson (1973) and Hoare (1974)
    - Concept, but no implementation
    - Requires Signal to be the last statement (Hansen)
    - Requires relinquishing CPU to signaler (Hoare)
  * **Mesa** (1977)
    - Monitor in language, but signaler keeps mutex and CPU
    - Waiter simply put on ready queue, with no special priority
    - 广泛使用
    - Java `synchronized` 关键词实现了这个模型（只有一个条件变量）
    - [论文《Experience with Processes and Monitors in Mesa》](https://people.eecs.berkeley.edu/~brewer/cs262/Mesa.pdf)
- 当线程 t2 的操作使得线程 t1 等待的条件满足时，t2 如何执行？
  * Hanson：t2 通知 t1，t2 结束
  * Hoare：t2 通知 t1，t2 阻塞，t1 执行至完毕，唤醒 t2
  * Mesa：t2 通知 t1，t2 继续执行，t1 从条件变量等待队列进入入口等待队列（但是 t1 执行的时候要再次检查条件，这就是这个模型下 while 循环检查条件必不可少的原因）

### 经典并发场景

- 生产者-消费者问题（Producer-Consumer）
- 哲学家就餐问题
- 读者-写者问题

