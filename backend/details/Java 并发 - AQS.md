# AbstractQueuedSynchronizer

java.util.concurrent包的核心类是AbstractQueuedSynchronizer，AQS是一个同步器+阻塞锁的基本架构，用于控制加锁和释放锁，并在内部维护一个FIFO的线程等待队列。

- state
- 同步队列，等待队列
- state=0, 没有任何线程占有共享资源的锁
- state=1, 则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待，AQS内部通过内部类Node构成FIFO的同步队列来完成线程获取锁的排队工作，同时利用内部类ConditionObject构建等待队列，当Condition调用wait()方法后，线程将会加入等待队列中，而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中进行锁竞争。注意这里涉及到两种队列，一种的同步队列，当线程请求锁而等待的后将加入同步队列等待，而另一种则是等待队列(可有多个)，通过Condition调用await()方法释放锁后，将加入等待队列。
- state 1代表锁已被占用”这点说得不太对，或是说不严谨吧，state应该是≥1时，表示锁已经被占用。因为是可重入的，每重入一次，锁会+1。

AQS作为基础组件，对于锁的实现存在两种不同的模式，即共享模式(如Semaphore)和独占模式(如ReetrantLock)，无论是共享模式还是独占模式的实现类，其内部都是基于AQS实现的，也都维持着一个虚拟的同步队列，当请求锁的线程超过现有模式的限制时，会将线程包装成Node结点并将线程当前必要的信息存储到node结点中，然后加入同步队列等会获取锁，而这系列操作都有AQS协助我们完成，这也是作为基础组件的原因，无论是Semaphore还是ReetrantLock，其内部绝大多数方法都是间接调用AQS完成的
